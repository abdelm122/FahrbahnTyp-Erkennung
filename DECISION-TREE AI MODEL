#include <M5Unified.h>
#include "road_tree_quantized.h"    //hier muss datei in gleiche pfad sein 

#include <WiFi.h>
#include <WebServer.h>

#include <math.h>
#include <string.h>
#include <algorithm>

// =========================
// iPhone Hotspot STA (optional)
// =========================
static const char* WIFI_SSID = "Abdelmounaim";
static const char* WIFI_PASS = "1234567800";

// =========================
// ATOMS3 Access Point (RECOMMENDED for iPhone browser)
// iPhone connects to this AP and opens: http://192.168.4.1
// =========================
static const char* AP_SSID = "ATOMS3-RoadAI";
static const char* AP_PASS = "12345678"; // min 8 chars

// =========================
// IMU API switch (depends on M5Unified version)
// 0 = getAccel/getGyro
// 1 = getAccelData/getGyroData
// =========================
#define IMU_API_GETACCELDATA 0

// If accel is m/s^2 instead of g, set to 1
#define ACC_IN_MPS2 0

// =========================
// Orientation handling
// Cable on the right often means a 90° rotation.
// Try: 90, then 0, then 270.
// =========================
#define ROT_Z_DEG 90   // 0, 90, 180, 270
#define FLIP_X 0
#define FLIP_Y 0
#define FLIP_Z 0

// =========================
// Config
// =========================
static constexpr float FS_HZ = 50.0f;
static constexpr int   WIN_SAMPLES = (int)(FS_HZ * 4.0f + 0.5f);   // 200
static constexpr int   HOP_SAMPLES = (int)(FS_HZ * 2.0f + 0.5f);   // 100

static constexpr float ACC_GRAVITY_FC_HZ = 0.3f;
static constexpr float GYRO_BIAS_FC_HZ   = 0.1f;

static constexpr bool  PRINT_SERIAL = true;

// =========================
// German labels (must match class order: 3adi, mobalat, trabi)
// =========================
static const char* const ROAD_CLASS_DE[ROAD_N_CLASSES] = {
  "Asphalt (normal)",     // 3adi
  "Pflaster/Uneben",      // mobalat
  "Schotter/Erde"         // trabi
};

// =========================
// Web server
// =========================
WebServer server(80);

// Shared state for web
static float g_last_norm[6] = {0,0,0,0,0,0};
static float g_proba_ema[ROAD_N_CLASSES] = {0,0,0}; // smoothed probabilities
static int   g_last_cls = 0;
static float g_last_conf = 0.0f;
static uint32_t g_last_pred_ms = 0;

// =========================
// Ring buffer: normalized signals [AX,AY,AZ,GX,GY,GZ]
// =========================
static float ringBuf[WIN_SAMPLES][6];
static int   ringCount = 0;
static int   ringHead  = 0;
static int   hopCounter = 0;

// Preprocessing state
static float g_est[3] = {0,0,0};
static float gyro_bias[3] = {0,0,0};

static float acc_alpha = 0.0f;
static float gyro_alpha = 0.0f;

static float feat[ROAD_N_FEATURES];

// --------------------------- EMA alpha ---------------------------
static float ema_alpha(float fc_hz, float fs_hz) {
  if (fc_hz <= 0.0f || fs_hz <= 0.0f) return 1.0f;
  return 1.0f - expf(-2.0f * (float)M_PI * fc_hz / fs_hz);
}

// --------------------------- Orientation helpers ---------------------------
static inline void rotate_xy(float& x, float& y) {
#if ROT_Z_DEG == 0
  (void)x; (void)y;
#elif ROT_Z_DEG == 90
  float nx = y;
  float ny = -x;
  x = nx; y = ny;
#elif ROT_Z_DEG == 180
  x = -x; y = -y;
#elif ROT_Z_DEG == 270
  float nx = -y;
  float ny = x;
  x = nx; y = ny;
#endif
}

static inline void apply_orientation(float& ax, float& ay, float& az,
                                     float& gx, float& gy, float& gz) {
  rotate_xy(ax, ay);
  rotate_xy(gx, gy);

#if FLIP_X
  ax = -ax; gx = -gx;
#endif
#if FLIP_Y
  ay = -ay; gy = -gy;
#endif
#if FLIP_Z
  az = -az; gz = -gz;
#endif
}

// --------------------------- Sorting helpers ---------------------------
static int cmp_float(const void* a, const void* b) {
  float fa = *(const float*)a;
  float fb = *(const float*)b;
  return (fa > fb) - (fa < fb);
}

static float median_of_copy(const float* x, int n, float* tmp) {
  memcpy(tmp, x, n * sizeof(float));
  qsort(tmp, n, sizeof(float), cmp_float);
  if (n & 1) return tmp[n/2];
  return 0.5f * (tmp[n/2 - 1] + tmp[n/2]);
}

static float percentile_sorted(const float* xs, int n, float p01) {
  if (n <= 1) return xs[0];
  float idx = p01 * (n - 1);
  int i0 = (int)floorf(idx);
  int i1 = i0 + 1;
  if (i1 >= n) return xs[n-1];
  float frac = idx - (float)i0;
  return xs[i0] * (1.0f - frac) + xs[i1] * frac;
}

static float iqr_of_copy(const float* x, int n, float* tmp) {
  memcpy(tmp, x, n * sizeof(float));
  qsort(tmp, n, sizeof(float), cmp_float);
  float q25 = percentile_sorted(tmp, n, 0.25f);
  float q75 = percentile_sorted(tmp, n, 0.75f);
  return q75 - q25;
}

static float mad_of_copy(const float* x, int n, float* tmp, float* tmp2) {
  float med = median_of_copy(x, n, tmp);
  for (int i = 0; i < n; i++) tmp2[i] = fabsf(x[i] - med);
  return median_of_copy(tmp2, n, tmp);
}

// --------------------------- Spectral features (Goertzel) ---------------------------
static void goertzel_power_bins(
  const float* x, int n, float fs,
  int kmax, float* P_out, float* freqs_out
) {
  for (int k = 0; k <= kmax; k++) {
    float w = 2.0f * (float)M_PI * (float)k / (float)n;
    float cw = cosf(w);
    float coeff = 2.0f * cw;
    float s_prev = 0.0f;
    float s_prev2 = 0.0f;

    for (int i = 0; i < n; i++) {
      float s = x[i] + coeff * s_prev - s_prev2;
      s_prev2 = s_prev;
      s_prev = s;
    }
    float power = s_prev2*s_prev2 + s_prev*s_prev - coeff*s_prev*s_prev2;
    if (power < 0.0f) power = 0.0f;

    P_out[k] = power;
    freqs_out[k] = ((float)k * fs) / (float)n;
  }
}

static void spectral_feats(
  const float* x_raw, int n, float fs,
  float* spec_centroid,
  float* spec_entropy,
  float* dom_freq,
  float* bandp_0_3, float* bandp_3_6, float* bandp_6_10, float* bandp_10_20
) {
  static float xw[WIN_SAMPLES];

  float mean = 0.0f;
  for (int i = 0; i < n; i++) mean += x_raw[i];
  mean /= (float)n;

  for (int i = 0; i < n; i++) {
    float hann = 0.5f - 0.5f * cosf(2.0f * (float)M_PI * (float)i / (float)(n - 1));
    xw[i] = (x_raw[i] - mean) * hann;
  }

  int kmax = (int)floorf(20.0f * (float)n / fs);
  if (kmax < 1) kmax = 1;
  if (kmax > n/2) kmax = n/2;

  static float P[WIN_SAMPLES/2 + 1];
  static float F[WIN_SAMPLES/2 + 1];

  goertzel_power_bins(xw, n, fs, kmax, P, F);

  float psum = 1e-12f;
  for (int k = 0; k <= kmax; k++) psum += P[k];

  int kbest = 0;
  float pbest = -1.0f;
  for (int k = 0; k <= kmax; k++) {
    if (P[k] > pbest) { pbest = P[k]; kbest = k; }
  }
  *dom_freq = F[kbest];

  float num = 0.0f;
  for (int k = 0; k <= kmax; k++) num += F[k] * P[k];
  *spec_centroid = num / psum;

  float ent = 0.0f;
  int bins = kmax + 1;
  float logbins = logf((float)std::max(2, bins));
  for (int k = 0; k <= kmax; k++) {
    float p = P[k] / psum;
    ent += -p * logf(p + 1e-12f);
  }
  *spec_entropy = ent / logbins;

  float b03=0,b36=0,b610=0,b1020=0;
  for (int k = 0; k <= kmax; k++) {
    float f = F[k];
    float p = P[k];
    if (f >= 0.0f && f < 3.0f) b03 += p;
    else if (f >= 3.0f && f < 6.0f) b36 += p;
    else if (f >= 6.0f && f < 10.0f) b610 += p;
    else if (f >= 10.0f && f < 20.0f) b1020 += p;
  }
  *bandp_0_3   = b03 / psum;
  *bandp_3_6   = b36 / psum;
  *bandp_6_10  = b610 / psum;
  *bandp_10_20 = b1020 / psum;
}

// --------------------------- Correlation ---------------------------
static float corr_coef(const float* a, const float* b, int n) {
  float ma = 0.0f, mb = 0.0f;
  for (int i = 0; i < n; i++) { ma += a[i]; mb += b[i]; }
  ma /= (float)n; mb /= (float)n;

  float num = 0.0f, da2 = 0.0f, db2 = 0.0f;
  for (int i = 0; i < n; i++) {
    float da = a[i] - ma;
    float db = b[i] - mb;
    num += da * db;
    da2 += da * da;
    db2 += db * db;
  }
  float denom = sqrtf(da2 * db2) + 1e-12f;
  return num / denom;
}

// --------------------------- Feature extraction (126) ---------------------------
static int extract_features_126(const float window[WIN_SAMPLES][6], float fs, float* out_feat) {
  static float x[WIN_SAMPLES];
  static float tmp[WIN_SAMPLES];
  static float tmp2[WIN_SAMPLES];

  int idx = 0;

  for (int ch = 0; ch < 6; ch++) {
    float mn = 0.0f;
    float mn2 = 0.0f;
    float vmin = 1e30f, vmax = -1e30f;
    int zc = 0;
    float prev_sign = 1.0f;

    for (int i = 0; i < WIN_SAMPLES; i++) {
      float v = window[i][ch];
      x[i] = v;
      mn += v;
      mn2 += v*v;
      if (v < vmin) vmin = v;
      if (v > vmax) vmax = v;

      float s = (v >= 0.0f) ? 1.0f : -1.0f;
      if (i > 0 && s != prev_sign) zc++;
      prev_sign = s;
    }

    float mean = mn / (float)WIN_SAMPLES;
    float var = (mn2 / (float)WIN_SAMPLES) - mean*mean;
    if (var < 1e-12f) var = 1e-12f;
    float stdv = sqrtf(var);

    float ptp = vmax - vmin;
    float energy = mn2 / (float)WIN_SAMPLES;
    float rms = sqrtf(energy);
    float zcr = (float)zc / (float)(WIN_SAMPLES - 1);

    float median = median_of_copy(x, WIN_SAMPLES, tmp);
    float mad = mad_of_copy(x, WIN_SAMPLES, tmp, tmp2);
    float iqr = iqr_of_copy(x, WIN_SAMPLES, tmp);

    float skew = 0.0f;
    float kurt = 0.0f;
    for (int i = 0; i < WIN_SAMPLES; i++) {
      float z = (x[i] - mean) / (stdv + 1e-12f);
      skew += z*z*z;
      kurt += z*z*z*z;
    }
    skew /= (float)WIN_SAMPLES;
    kurt = (kurt / (float)WIN_SAMPLES) - 3.0f;

    out_feat[idx++] = mean;
    out_feat[idx++] = stdv;
    out_feat[idx++] = vmin;
    out_feat[idx++] = vmax;
    out_feat[idx++] = ptp;
    out_feat[idx++] = median;
    out_feat[idx++] = mad;
    out_feat[idx++] = iqr;
    out_feat[idx++] = rms;
    out_feat[idx++] = energy;
    out_feat[idx++] = zcr;
    out_feat[idx++] = skew;
    out_feat[idx++] = kurt;

    float spec_centroid, spec_entropy, dom_freq;
    float b03, b36, b610, b1020;
    spectral_feats(x, WIN_SAMPLES, fs, &spec_centroid, &spec_entropy, &dom_freq, &b03, &b36, &b610, &b1020);

    out_feat[idx++] = spec_centroid;
    out_feat[idx++] = spec_entropy;
    out_feat[idx++] = dom_freq;
    out_feat[idx++] = b03;
    out_feat[idx++] = b36;
    out_feat[idx++] = b610;
    out_feat[idx++] = b1020;
  }

  static float ax[WIN_SAMPLES], ay[WIN_SAMPLES], az[WIN_SAMPLES];
  static float gx[WIN_SAMPLES], gy[WIN_SAMPLES], gz[WIN_SAMPLES];

  for (int i = 0; i < WIN_SAMPLES; i++) {
    ax[i] = window[i][0];
    ay[i] = window[i][1];
    az[i] = window[i][2];
    gx[i] = window[i][3];
    gy[i] = window[i][4];
    gz[i] = window[i][5];
  }

  out_feat[idx++] = corr_coef(ax, ay, WIN_SAMPLES);
  out_feat[idx++] = corr_coef(ax, az, WIN_SAMPLES);
  out_feat[idx++] = corr_coef(ay, az, WIN_SAMPLES);

  out_feat[idx++] = corr_coef(gx, gy, WIN_SAMPLES);
  out_feat[idx++] = corr_coef(gx, gz, WIN_SAMPLES);
  out_feat[idx++] = corr_coef(gy, gz, WIN_SAMPLES);

  return idx;
}

// --------------------------- IMU read ---------------------------
static bool readIMU(float& ax_g, float& ay_g, float& az_g,
                    float& gx_dps, float& gy_dps, float& gz_dps) {
  if (!M5.Imu.isEnabled()) return false;

  float ax, ay, az;
  float gx, gy, gz;

#if IMU_API_GETACCELDATA
  bool okA = M5.Imu.getAccelData(&ax, &ay, &az);
  bool okG = M5.Imu.getGyroData(&gx, &gy, &gz);
#else
  bool okA = M5.Imu.getAccel(&ax, &ay, &az);
  bool okG = M5.Imu.getGyro(&gx, &gy, &gz);
#endif
  if (!okA || !okG) return false;

#if ACC_IN_MPS2
  ax_g = ax / 9.80665f;
  ay_g = ay / 9.80665f;
  az_g = az / 9.80665f;
#else
  ax_g = ax; ay_g = ay; az_g = az;
#endif

  gx_dps = gx; gy_dps = gy; gz_dps = gz;
  return true;
}

// --------------------------- Preprocess sample ---------------------------
static void preprocess_sample(
  float ax_g, float ay_g, float az_g,
  float gx_dps, float gy_dps, float gz_dps,
  float out_norm[6]
) {
  apply_orientation(ax_g, ay_g, az_g, gx_dps, gy_dps, gz_dps);

  // gravity estimate (EMA)
  g_est[0] = acc_alpha * ax_g + (1.0f - acc_alpha) * g_est[0];
  g_est[1] = acc_alpha * ay_g + (1.0f - acc_alpha) * g_est[1];
  g_est[2] = acc_alpha * az_g + (1.0f - acc_alpha) * g_est[2];

  float ax_lin = ax_g - g_est[0];
  float ay_lin = ay_g - g_est[1];
  float az_lin = az_g - g_est[2];

  // gyro bias (slow EMA)
  gyro_bias[0] = gyro_alpha * gx_dps + (1.0f - gyro_alpha) * gyro_bias[0];
  gyro_bias[1] = gyro_alpha * gy_dps + (1.0f - gyro_alpha) * gyro_bias[1];
  gyro_bias[2] = gyro_alpha * gz_dps + (1.0f - gyro_alpha) * gyro_bias[2];

  float gx_d = gx_dps - gyro_bias[0];
  float gy_d = gy_dps - gyro_bias[1];
  float gz_d = gz_dps - gyro_bias[2];

  float raw[6] = {ax_lin, ay_lin, az_lin, gx_d, gy_d, gz_d};

  for (int i = 0; i < 6; i++) {
    out_norm[i] = (raw[i] - ROAD_SENSOR_MEAN[i]) / (ROAD_SENSOR_STD[i] + 1e-12f);
  }
}

// --------------------------- Ring buffer ---------------------------
static void ring_push(const float s6[6]) {
  for (int i = 0; i < 6; i++) ringBuf[ringHead][i] = s6[i];
  ringHead = (ringHead + 1) % WIN_SAMPLES;
  if (ringCount < WIN_SAMPLES) ringCount++;
}

static void ring_copy_window(float outWin[WIN_SAMPLES][6]) {
  int start = (ringCount == WIN_SAMPLES) ? ringHead : 0;
  for (int i = 0; i < WIN_SAMPLES; i++) {
    int idx = (start + i) % WIN_SAMPLES;
    for (int c = 0; c < 6; c++) outWin[i][c] = ringBuf[idx][c];
  }
}

// --------------------------- Tree traversal to get leaf + proba vector ---------------------------
static int road_leaf_node_from_feat_q(const int32_t* feat_q) {
  int node = 0;
  while (node >= 0 && node < ROAD_N_NODES) {
    int f = (int)ROAD_FEATURE[node];
    if (f < 0) break;
    int32_t th = ROAD_THRESHOLD_Q[node];
    int16_t left = ROAD_CHILD_LEFT[node];
    int16_t right = ROAD_CHILD_RIGHT[node];
    node = (feat_q[f] <= th) ? (int)left : (int)right;
  }
  return node;
}

static void road_predict_proba(const float* feat_f, float* out_proba, int* out_cls, float* out_conf) {
  static int32_t fq[ROAD_N_FEATURES];
  road_quantize_features(feat_f, fq);

  int node = road_leaf_node_from_feat_q(fq);

  float best = -1.0f;
  int bestc = 0;
  for (int c = 0; c < ROAD_N_CLASSES; c++) {
    float p = (float)ROAD_LEAF_PROBA_Q15[node][c] / 32767.0f;
    out_proba[c] = p;
    if (p > best) { best = p; bestc = c; }
  }
  if (out_cls) *out_cls = bestc;
  if (out_conf) *out_conf = best;
}

// --------------------------- Display ---------------------------
static void show_result(int cls, float conf01, const float* proba) {
  M5.Display.clear();
  M5.Display.setTextSize(2);
  M5.Display.setCursor(0, 0);

  M5.Display.printf("Strassentyp:\n%s\n", ROAD_CLASS_DE[cls]);
  M5.Display.printf("Sicherheit:\n%.1f%%\n\n", conf01 * 100.0f);

  // show all class percentages (useful for debugging bias)
  for (int c = 0; c < ROAD_N_CLASSES; c++) {
    M5.Display.printf("%s: %.0f%%\n", ROAD_CLASS_DE[c], proba[c] * 100.0f);
  }
}

// =========================
// Web UI (Polling)
// =========================
static const char INDEX_HTML[] PROGMEM = R"HTML(
<!doctype html><html><head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ATOMS3 Road AI</title>
<style>
body{font-family:system-ui,Arial;margin:12px;}
.row{display:flex;gap:12px;flex-wrap:wrap;}
.card{border:1px solid #ddd;border-radius:10px;padding:10px;min-width:260px;}
canvas{border:1px solid #ddd;border-radius:10px;}
.big{font-size:20px;font-weight:700;}
.muted{color:#666;}
</style></head><body>
<div class="row">
  <div class="card">
    <div class="big">Straßentyp: <span id="road">-</span></div>
    <div class="big">Sicherheit: <span id="conf">-</span></div>
    <div class="muted" id="ipinfo">-</div>
    <hr/>
    <div><b>Alle Klassen:</b></div>
    <div id="p0">-</div><div id="p1">-</div><div id="p2">-</div>
  </div>
  <div class="card">
    <div class="big">Live IMU</div>
    <div class="muted">AX/AY/AZ (norm), GX/GY/GZ (norm)</div>
  </div>
</div>
<p></p>
<canvas id="cv" width="360" height="420"></canvas>

<script>
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const N = 200;
const buf = {ax:Array(N).fill(0),ay:Array(N).fill(0),az:Array(N).fill(0),gx:Array(N).fill(0),gy:Array(N).fill(0),gz:Array(N).fill(0)};
function push(a,v){a.push(v); if(a.length>N)a.shift();}

function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);
  ctx.fillStyle="#000"; ctx.font="14px system-ui";
  ctx.fillText("Accel",10,18); ctx.fillText("Gyro",10,218);
  ctx.strokeStyle="#eee";
  for(let y=30;y<200;y+=20){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(cv.width,y);ctx.stroke();}
  for(let y=230;y<cv.height;y+=20){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(cv.width,y);ctx.stroke();}
  function plot(series,y0,h,stroke){
    let m=0.1; for(const v of series)m=Math.max(m,Math.abs(v));
    const scale=(h*0.45)/m, dx=cv.width/(series.length-1);
    ctx.strokeStyle=stroke; ctx.beginPath();
    for(let i=0;i<series.length;i++){
      const x=i*dx, y=y0+h/2 - series[i]*scale;
      if(i===0)ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  plot(buf.ax,30,170,"#d00"); plot(buf.ay,30,170,"#0a0"); plot(buf.az,30,170,"#00a");
  plot(buf.gx,230,170,"#d00"); plot(buf.gy,230,170,"#0a0"); plot(buf.gz,230,170,"#00a");
  requestAnimationFrame(draw);
}

async function pollStatus(){
  try{
    const r=await fetch('/status',{cache:'no-store'});
    const j=await r.json();
    document.getElementById('road').textContent=j.road_de;
    document.getElementById('conf').textContent=(j.conf*100).toFixed(1)+'%';
    document.getElementById('ipinfo').textContent=j.info;
    document.getElementById('p0').textContent=j.p0_name+': '+(j.p0*100).toFixed(0)+'%';
    document.getElementById('p1').textContent=j.p1_name+': '+(j.p1*100).toFixed(0)+'%';
    document.getElementById('p2').textContent=j.p2_name+': '+(j.p2*100).toFixed(0)+'%';
  }catch(e){}
  setTimeout(pollStatus, 600);
}

async function pollIMU(){
  try{
    const r=await fetch('/imu',{cache:'no-store'});
    const j=await r.json();
    push(buf.ax,j.ax); push(buf.ay,j.ay); push(buf.az,j.az);
    push(buf.gx,j.gx); push(buf.gy,j.gy); push(buf.gz,j.gz);
  }catch(e){}
  setTimeout(pollIMU, 200);
}

draw(); pollStatus(); pollIMU();
</script>
</body></html>
)HTML";

// --------------------------- Web handlers ---------------------------
static String ipInfoStr;

static void handleRoot() {
  server.send_P(200, "text/html", INDEX_HTML);
}

static void handleStatus() {
  char out[512];
  snprintf(out, sizeof(out),
    "{\"road_de\":\"%s\",\"conf\":%.6f,"
    "\"p0\":%.6f,\"p1\":%.6f,\"p2\":%.6f,"
    "\"p0_name\":\"%s\",\"p1_name\":\"%s\",\"p2_name\":\"%s\","
    "\"info\":\"%s\"}",
    ROAD_CLASS_DE[g_last_cls], (double)g_last_conf,
    (double)g_proba_ema[0], (double)g_proba_ema[1], (double)g_proba_ema[2],
    ROAD_CLASS_DE[0], ROAD_CLASS_DE[1], ROAD_CLASS_DE[2],
    ipInfoStr.c_str()
  );
  server.send(200, "application/json", out);
}

static void handleIMU() {
  char out[256];
  snprintf(out, sizeof(out),
    "{\"ax\":%.6f,\"ay\":%.6f,\"az\":%.6f,\"gx\":%.6f,\"gy\":%.6f,\"gz\":%.6f}",
    (double)g_last_norm[0], (double)g_last_norm[1], (double)g_last_norm[2],
    (double)g_last_norm[3], (double)g_last_norm[4], (double)g_last_norm[5]
  );
  server.send(200, "application/json", out);
}

// --------------------------- WiFi (AP+STA) ---------------------------
static void wifiStartAPSTA() {
  WiFi.mode(WIFI_AP_STA);
  WiFi.setSleep(false);

  // Start AP (reliable access from iPhone)
  WiFi.softAP(AP_SSID, AP_PASS);
  IPAddress apIP = WiFi.softAPIP();

  // Try STA connect to iPhone hotspot (optional)
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  uint32_t t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 12000) {
    delay(200);
  }

  IPAddress staIP = WiFi.localIP();

  ipInfoStr = "AP: http://192.168.4.1  | STA: ";
  if (WiFi.status() == WL_CONNECTED) ipInfoStr += staIP.toString();
  else ipInfoStr += "not connected";

  if (PRINT_SERIAL) {
    Serial.println(ipInfoStr);
  }

  // screen info
  M5.Display.clear();
  M5.Display.setCursor(0, 0);
  M5.Display.setTextSize(2);
  M5.Display.println("Web:");
  M5.Display.println("AP: 192.168.4.1");
  M5.Display.print("STA: ");
  M5.Display.println((WiFi.status()==WL_CONNECTED) ? staIP.toString() : String("NC"));
  M5.Display.println();
  M5.Display.println("Connect iPhone to:");
  M5.Display.println(AP_SSID);

  // routes
  server.on("/", handleRoot);
  server.on("/status", handleStatus);
  server.on("/imu", handleIMU);
  server.onNotFound([](){ server.send(404, "text/plain", "Not found"); });
  server.begin();
}

// =========================
// Setup/Loop
// =========================
void setup() {
  auto cfg = M5.config();
  M5.begin(cfg);
  Serial.begin(115200);

  M5.Display.setRotation(0);
  M5.Display.setTextSize(2);
  M5.Display.clear();
  M5.Display.setCursor(0, 0);
  M5.Display.println("Road AI init...");

  if (!M5.Imu.begin()) {
    M5.Display.println("IMU FAIL");
    while (true) delay(200);
  }

  acc_alpha = ema_alpha(ACC_GRAVITY_FC_HZ, FS_HZ);
  gyro_alpha = ema_alpha(GYRO_BIAS_FC_HZ, FS_HZ);

  // Prime state
  float ax, ay, az, gx, gy, gz;
  if (readIMU(ax, ay, az, gx, gy, gz)) {
    apply_orientation(ax, ay, az, gx, gy, gz);
    g_est[0] = ax; g_est[1] = ay; g_est[2] = az;
    gyro_bias[0] = gx; gyro_bias[1] = gy; gyro_bias[2] = gz;
  }

  // init EMA proba
  for (int c = 0; c < ROAD_N_CLASSES; c++) g_proba_ema[c] = 1.0f / ROAD_N_CLASSES;

  wifiStartAPSTA();
}

void loop() {
  // serve web quickly
  server.handleClient();

  static uint32_t last_ms = 0;
  uint32_t now = millis();
  uint32_t period_ms = (uint32_t)(1000.0f / FS_HZ + 0.5f);
  if (now - last_ms < period_ms) return;
  last_ms = now;

  float ax, ay, az, gx, gy, gz;
  if (!readIMU(ax, ay, az, gx, gy, gz)) return;

  float norm6[6];
  preprocess_sample(ax, ay, az, gx, gy, gz, norm6);

  // latest IMU for web plot
  for (int i = 0; i < 6; i++) g_last_norm[i] = norm6[i];

  ring_push(norm6);
  if (ringCount < WIN_SAMPLES) return;

  hopCounter++;
  if (hopCounter < HOP_SAMPLES) return;
  hopCounter = 0;

  static float win[WIN_SAMPLES][6];
  ring_copy_window(win);

  int nfeat = extract_features_126(win, FS_HZ, feat);
  if (nfeat != ROAD_N_FEATURES) return;

  float proba[ROAD_N_CLASSES];
  int cls = 0;
  float conf = 0.0f;
  road_predict_proba(feat, proba, &cls, &conf);

  // Smooth probabilities (EMA)
  const float a = 0.50f;
  for (int c = 0; c < ROAD_N_CLASSES; c++) {
    g_proba_ema[c] = a * proba[c] + (1.0f - a) * g_proba_ema[c];
  }
  // recompute argmax from smoothed
  int bestc = 0;
  float bestp = g_proba_ema[0];
  for (int c = 1; c < ROAD_N_CLASSES; c++) {
    if (g_proba_ema[c] > bestp) { bestp = g_proba_ema[c]; bestc = c; }
  }

  g_last_cls = bestc;
  g_last_conf = bestp;
  g_last_pred_ms = millis();

  show_result(g_last_cls, g_last_conf, g_proba_ema);

  if (PRINT_SERIAL) {
    Serial.printf("Strassentyp=%s  Sicherheit=%.3f  (p0=%.2f p1=%.2f p2=%.2f)\n",
      ROAD_CLASS_DE[g_last_cls], g_last_conf,
      g_proba_ema[0], g_proba_ema[1], g_proba_ema[2]
    );
  }
}
