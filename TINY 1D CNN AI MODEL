#include <M5Unified.h>
#include <WiFi.h>
#include <WebServer.h>

#include <math.h>
#include <string.h>
#include <algorithm>

// ====== CNN HEADER (generated once by python from best_model.keras) ======
#include "tiny_d1cnn.h"

// ====== Normalization params from Step 2 ======
// Must define:
// static constexpr float TRAIN_MEAN[6] = {...};
// static constexpr float TRAIN_STD[6]  = {...};
#include "norm_params.h"

// =========================
// WiFi config
// =========================
static const char* WIFI_SSID = "Abdelmounaim";     // optional STA
static const char* WIFI_PASS = "1234567800";

static const char* AP_SSID = "ATOMS3-RoadAI";      // recommended AP
static const char* AP_PASS = "12345678";           // min 8 chars

// =========================
// IMU API switch (depends on M5Unified version)
// 0 = getAccel/getGyro
// 1 = getAccelData/getGyroData
// =========================
#define IMU_API_GETACCELDATA 0

// If accel is m/s^2 instead of g, set to 1
#define ACC_IN_MPS2 0

// =========================
// Orientation handling (try 90, then 0, then 270)
// =========================
#define ROT_Z_DEG 90
#define FLIP_X 0
#define FLIP_Y 0
#define FLIP_Z 0

// =========================
// Sampling config
// =========================
static constexpr float FS_HZ = 50.0f;
static constexpr uint32_t SAMPLE_MS = (uint32_t)(1000.0f / FS_HZ + 0.5f);

// Window sizes must match CNN header
static constexpr int WIN_SAMPLES = TINY_T;        // from tiny_d1cnn.h
static constexpr int HOP_SAMPLES = (TINY_T / 2);  // prediction every half-window

static constexpr bool PRINT_SERIAL = true;

// =========================
// Labels (order must match training: 3adi, mobalat, trabi)
// =========================
static const char* const ROAD_CLASS_DE[TINY_K] = {
  "Asphalt (normal)",
  "Pflaster/Uneben",
  "Schotter/Erde"
};

// =========================
// Web server
// =========================
WebServer server(80);
static String ipInfoStr;

// Shared state for web
static float g_last_plot[6] = {0,0,0,0,0,0};     // what we plot (filtered IMU)
static float g_proba_ema[TINY_K] = {0};           // smoothed probabilities
static int   g_last_cls = 0;                      // stable class (output)
static float g_last_conf = 0.0f;                  // stable confidence
static uint32_t g_last_pred_ms = 0;

// Ring buffer (filtered raw)
static float ringBuf[WIN_SAMPLES][6];
static int   ringCount = 0;
static int   ringHead  = 0;
static int   hopCounter = 0;

// =====================
// STABILITY: reduce jumping
// =====================
// IMU low-pass filter
static float imu_filt[6] = {0,0,0,0,0,0};
static constexpr float IMU_EMA_A = 0.20f;  // 0.15..0.30 (smaller => more stable)

// Probability smoothing + hysteresis switching
static int   g_stable_cls = 0;
static int   g_cand_cls = -1;
static int   g_cand_cnt = 0;
static uint32_t g_last_switch_ms = 0;

// These are "strong stability" defaults
static constexpr float PROBA_EMA_A        = 0.15f; // smaller => smoother probs
static constexpr float MIN_CONF_TO_SWITCH = 0.70f; // require strong confidence to switch
static constexpr float HYST_MARGIN        = 0.10f; // new class must beat current by this margin
static constexpr int   STREAK_N           = 4;     // must win 4 times in a row
static constexpr uint32_t HOLD_MS         = 3500;  // hold class for 3.5s after switch

// =========================
// Orientation helpers
// =========================
static inline void rotate_xy(float& x, float& y) {
#if ROT_Z_DEG == 0
  (void)x; (void)y;
#elif ROT_Z_DEG == 90
  float nx = y;
  float ny = -x;
  x = nx; y = ny;
#elif ROT_Z_DEG == 180
  x = -x; y = -y;
#elif ROT_Z_DEG == 270
  float nx = -y;
  float ny = x;
  x = nx; y = ny;
#endif
}

static inline void apply_orientation(float& ax, float& ay, float& az,
                                     float& gx, float& gy, float& gz) {
  rotate_xy(ax, ay);
  rotate_xy(gx, gy);

#if FLIP_X
  ax = -ax; gx = -gx;
#endif
#if FLIP_Y
  ay = -ay; gy = -gy;
#endif
#if FLIP_Z
  az = -az; gz = -gz;
#endif
}

// =========================
// IMU read
// =========================
static bool readIMU(float& ax_g, float& ay_g, float& az_g,
                    float& gx_dps, float& gy_dps, float& gz_dps) {
  if (!M5.Imu.isEnabled()) return false;

  float ax, ay, az;
  float gx, gy, gz;

#if IMU_API_GETACCELDATA
  bool okA = M5.Imu.getAccelData(&ax, &ay, &az);
  bool okG = M5.Imu.getGyroData(&gx, &gy, &gz);
#else
  bool okA = M5.Imu.getAccel(&ax, &ay, &az);
  bool okG = M5.Imu.getGyro(&gx, &gy, &gz);
#endif
  if (!okA || !okG) return false;

#if ACC_IN_MPS2
  ax_g = ax / 9.80665f;
  ay_g = ay / 9.80665f;
  az_g = az / 9.80665f;
#else
  ax_g = ax; ay_g = ay; az_g = az;
#endif

  gx_dps = gx; gy_dps = gy; gz_dps = gz;
  return true;
}

// =========================
// Ring buffer helpers
// =========================
static void ring_push_raw(const float s6[6]) {
  for (int i = 0; i < 6; i++) ringBuf[ringHead][i] = s6[i];
  ringHead = (ringHead + 1) % WIN_SAMPLES;
  if (ringCount < WIN_SAMPLES) ringCount++;
}

static void ring_copy_window(float outWin[WIN_SAMPLES][6]) {
  int start = (ringCount == WIN_SAMPLES) ? ringHead : 0;
  for (int i = 0; i < WIN_SAMPLES; i++) {
    int idx = (start + i) % WIN_SAMPLES;
    for (int c = 0; c < 6; c++) outWin[i][c] = ringBuf[idx][c];
  }
}

// =========================
// CNN preprocessing
// 1) window mean remove per channel
// 2) standardize with TRAIN_MEAN/TRAIN_STD
// 3) build features (TINY_C==10 => mag_jerk; TINY_C==6 => base6)
// =========================
static void preprocess_window_offset_and_standardize(
  const float win_raw[WIN_SAMPLES][6],
  float win_proc[WIN_SAMPLES][6]
) {
  float mean6[6] = {0,0,0,0,0,0};
  for (int t = 0; t < WIN_SAMPLES; t++) {
    for (int c = 0; c < 6; c++) mean6[c] += win_raw[t][c];
  }
  for (int c = 0; c < 6; c++) mean6[c] /= (float)WIN_SAMPLES;

  for (int t = 0; t < WIN_SAMPLES; t++) {
    for (int c = 0; c < 6; c++) {
      float x = win_raw[t][c] - mean6[c];
      x = (x - TRAIN_MEAN[c]) / (TRAIN_STD[c] + 1e-12f);
      win_proc[t][c] = x;
    }
  }
}

static void build_features_mag_jerk(
  const float win_proc[WIN_SAMPLES][6],
  float* x_tc  // length WIN_SAMPLES*10
) {
  float prev_ax = win_proc[0][0], prev_ay = win_proc[0][1], prev_az = win_proc[0][2];
  float prev_gx = win_proc[0][3], prev_gy = win_proc[0][4], prev_gz = win_proc[0][5];

  for (int t = 0; t < WIN_SAMPLES; t++) {
    float ax = win_proc[t][0];
    float ay = win_proc[t][1];
    float az = win_proc[t][2];
    float gx = win_proc[t][3];
    float gy = win_proc[t][4];
    float gz = win_proc[t][5];

    x_tc[t*10 + 0] = ax;
    x_tc[t*10 + 1] = ay;
    x_tc[t*10 + 2] = az;
    x_tc[t*10 + 3] = gx;
    x_tc[t*10 + 4] = gy;
    x_tc[t*10 + 5] = gz;

    float acc_mag = sqrtf(ax*ax + ay*ay + az*az);
    float gyr_mag = sqrtf(gx*gx + gy*gy + gz*gz);
    x_tc[t*10 + 6] = acc_mag;
    x_tc[t*10 + 7] = gyr_mag;

    float dax = ax - prev_ax;
    float day = ay - prev_ay;
    float daz = az - prev_az;
    float dgx = gx - prev_gx;
    float dgy = gy - prev_gy;
    float dgz = gz - prev_gz;

    x_tc[t*10 + 8] = sqrtf(dax*dax + day*day + daz*daz);
    x_tc[t*10 + 9] = sqrtf(dgx*dgx + dgy*dgy + dgz*dgz);

    prev_ax = ax; prev_ay = ay; prev_az = az;
    prev_gx = gx; prev_gy = gy; prev_gz = gz;
  }
}

static void build_features_base6(
  const float win_proc[WIN_SAMPLES][6],
  float* x_tc  // length WIN_SAMPLES*6
) {
  for (int t = 0; t < WIN_SAMPLES; t++) {
    for (int c = 0; c < 6; c++) x_tc[t*6 + c] = win_proc[t][c];
  }
}

// =========================
// Display
// =========================
static void show_result(int cls, float conf01, const float* proba) {
  M5.Display.clear();
  M5.Display.setTextSize(2);
  M5.Display.setCursor(0, 0);

  M5.Display.printf("Strassentyp:\n%s\n", ROAD_CLASS_DE[cls]);
  M5.Display.printf("Sicherheit:\n%.1f%%\n\n", conf01 * 100.0f);

  for (int c = 0; c < TINY_K; c++) {
    M5.Display.printf("%s: %.0f%%\n", ROAD_CLASS_DE[c], proba[c] * 100.0f);
  }
}

// =========================
// Web UI (Polling)
// =========================
static const char INDEX_HTML[] PROGMEM = R"HTML(
<!doctype html><html><head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>ATOMS3 Road AI</title>
<style>
body{font-family:system-ui,Arial;margin:12px;}
.row{display:flex;gap:12px;flex-wrap:wrap;}
.card{border:1px solid #ddd;border-radius:10px;padding:10px;min-width:260px;}
canvas{border:1px solid #ddd;border-radius:10px;}
.big{font-size:20px;font-weight:700;}
.muted{color:#666;}
</style></head><body>
<div class="row">
  <div class="card">
    <div class="big">Stra√üentyp: <span id="road">-</span></div>
    <div class="big">Sicherheit: <span id="conf">-</span></div>
    <div class="muted" id="ipinfo">-</div>
    <hr/>
    <div><b>Alle Klassen:</b></div>
    <div id="p0">-</div><div id="p1">-</div><div id="p2">-</div>
  </div>
  <div class="card">
    <div class="big">Live IMU</div>
    <div class="muted">AX/AY/AZ, GX/GY/GZ (gefiltert)</div>
  </div>
</div>
<p></p>
<canvas id="cv" width="360" height="420"></canvas>

<script>
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const N = 200;
const buf = {ax:Array(N).fill(0),ay:Array(N).fill(0),az:Array(N).fill(0),gx:Array(N).fill(0),gy:Array(N).fill(0),gz:Array(N).fill(0)};
function push(a,v){a.push(v); if(a.length>N)a.shift();}

function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);
  ctx.fillStyle="#000"; ctx.font="14px system-ui";
  ctx.fillText("Accel",10,18); ctx.fillText("Gyro",10,218);
  ctx.strokeStyle="#eee";
  for(let y=30;y<200;y+=20){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(cv.width,y);ctx.stroke();}
  for(let y=230;y<cv.height;y+=20){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(cv.width,y);ctx.stroke();}
  function plot(series,y0,h,stroke){
    let m=0.1; for(const v of series)m=Math.max(m,Math.abs(v));
    const scale=(h*0.45)/m, dx=cv.width/(series.length-1);
    ctx.strokeStyle=stroke; ctx.beginPath();
    for(let i=0;i<series.length;i++){
      const x=i*dx, y=y0+h/2 - series[i]*scale;
      if(i===0)ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  plot(buf.ax,30,170,"#d00"); plot(buf.ay,30,170,"#0a0"); plot(buf.az,30,170,"#00a");
  plot(buf.gx,230,170,"#d00"); plot(buf.gy,230,170,"#0a0"); plot(buf.gz,230,170,"#00a");
  requestAnimationFrame(draw);
}

async function pollStatus(){
  try{
    const r=await fetch('/status',{cache:'no-store'});
    const j=await r.json();
    document.getElementById('road').textContent=j.road_de;
    document.getElementById('conf').textContent=(j.conf*100).toFixed(1)+'%';
    document.getElementById('ipinfo').textContent=j.info;
    document.getElementById('p0').textContent=j.p0_name+': '+(j.p0*100).toFixed(0)+'%';
    document.getElementById('p1').textContent=j.p1_name+': '+(j.p1*100).toFixed(0)+'%';
    document.getElementById('p2').textContent=j.p2_name+': '+(j.p2*100).toFixed(0)+'%';
  }catch(e){}
  setTimeout(pollStatus, 600);
}

async function pollIMU(){
  try{
    const r=await fetch('/imu',{cache:'no-store'});
    const j=await r.json();
    push(buf.ax,j.ax); push(buf.ay,j.ay); push(buf.az,j.az);
    push(buf.gx,j.gx); push(buf.gy,j.gy); push(buf.gz,j.gz);
  }catch(e){}
  setTimeout(pollIMU, 200);
}

draw(); pollStatus(); pollIMU();
</script>
</body></html>
)HTML";

// web handlers
static void handleRoot() {
  server.send_P(200, "text/html", INDEX_HTML);
}

static void handleStatus() {
  char out[512];
  snprintf(out, sizeof(out),
    "{\"road_de\":\"%s\",\"conf\":%.6f,"
    "\"p0\":%.6f,\"p1\":%.6f,\"p2\":%.6f,"
    "\"p0_name\":\"%s\",\"p1_name\":\"%s\",\"p2_name\":\"%s\","
    "\"info\":\"%s\"}",
    ROAD_CLASS_DE[g_last_cls], (double)g_last_conf,
    (double)g_proba_ema[0], (double)g_proba_ema[1], (double)g_proba_ema[2],
    ROAD_CLASS_DE[0], ROAD_CLASS_DE[1], ROAD_CLASS_DE[2],
    ipInfoStr.c_str()
  );
  server.send(200, "application/json", out);
}

static void handleIMU() {
  char out[256];
  snprintf(out, sizeof(out),
    "{\"ax\":%.6f,\"ay\":%.6f,\"az\":%.6f,\"gx\":%.6f,\"gy\":%.6f,\"gz\":%.6f}",
    (double)g_last_plot[0], (double)g_last_plot[1], (double)g_last_plot[2],
    (double)g_last_plot[3], (double)g_last_plot[4], (double)g_last_plot[5]
  );
  server.send(200, "application/json", out);
}

// WiFi start (AP + optional STA)
static void wifiStartAPSTA() {
  WiFi.mode(WIFI_AP_STA);
  WiFi.setSleep(false);

  WiFi.softAP(AP_SSID, AP_PASS);

  WiFi.begin(WIFI_SSID, WIFI_PASS);
  uint32_t t0 = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - t0 < 12000) {
    delay(200);
  }

  IPAddress staIP = WiFi.localIP();
  ipInfoStr = "AP: http://192.168.4.1  | STA: ";
  if (WiFi.status() == WL_CONNECTED) ipInfoStr += staIP.toString();
  else ipInfoStr += "not connected";

  if (PRINT_SERIAL) Serial.println(ipInfoStr);

  M5.Display.clear();
  M5.Display.setCursor(0, 0);
  M5.Display.setTextSize(2);
  M5.Display.println("Web:");
  M5.Display.println("AP: 192.168.4.1");
  M5.Display.print("STA: ");
  M5.Display.println((WiFi.status()==WL_CONNECTED) ? staIP.toString() : String("NC"));
  M5.Display.println();
  M5.Display.println("Connect iPhone to:");
  M5.Display.println(AP_SSID);

  server.on("/", handleRoot);
  server.on("/status", handleStatus);
  server.on("/imu", handleIMU);
  server.onNotFound([](){ server.send(404, "text/plain", "Not found"); });
  server.begin();
}

// =========================
// Setup / Loop
// =========================
void setup() {
  auto cfg = M5.config();
  M5.begin(cfg);
  Serial.begin(115200);

  M5.Display.setRotation(0);
  M5.Display.setTextSize(2);
  M5.Display.clear();
  M5.Display.setCursor(0, 0);
  M5.Display.println("Road AI init...");

  if (!M5.Imu.begin()) {
    M5.Display.println("IMU FAIL");
    while (true) delay(200);
  }

  // init EMA probs
  for (int c = 0; c < TINY_K; c++) g_proba_ema[c] = 1.0f / (float)TINY_K;
  g_stable_cls = 0;

  // init IMU filter state with first sample if possible
  float ax, ay, az, gx, gy, gz;
  if (readIMU(ax, ay, az, gx, gy, gz)) {
    apply_orientation(ax, ay, az, gx, gy, gz);
    imu_filt[0]=ax; imu_filt[1]=ay; imu_filt[2]=az;
    imu_filt[3]=gx; imu_filt[4]=gy; imu_filt[5]=gz;
  }

  wifiStartAPSTA();

  if (PRINT_SERIAL) {
    Serial.printf("CNN Header: T=%d C=%d K=%d\n", TINY_T, TINY_C, TINY_K);
  }
}

void loop() {
  server.handleClient();

  static uint32_t last_ms = 0;
  uint32_t now = millis();
  if (now - last_ms < SAMPLE_MS) return;
  last_ms = now;

  float ax, ay, az, gx, gy, gz;
  if (!readIMU(ax, ay, az, gx, gy, gz)) return;

  apply_orientation(ax, ay, az, gx, gy, gz);

  float raw6[6] = {ax, ay, az, gx, gy, gz};

  // IMU low-pass filter
  for (int i = 0; i < 6; i++) {
    imu_filt[i] = IMU_EMA_A * raw6[i] + (1.0f - IMU_EMA_A) * imu_filt[i];
  }

  float filt6[6] = {imu_filt[0], imu_filt[1], imu_filt[2], imu_filt[3], imu_filt[4], imu_filt[5]};

  // web plot shows filtered
  for (int i = 0; i < 6; i++) g_last_plot[i] = filt6[i];

  // push to ring buffer
  ring_push_raw(filt6);
  if (ringCount < WIN_SAMPLES) return;

  hopCounter++;
  if (hopCounter < HOP_SAMPLES) return;
  hopCounter = 0;

  // copy window
  static float win[WIN_SAMPLES][6];
  ring_copy_window(win);

  // preprocess window -> build CNN input
  static float win_proc[WIN_SAMPLES][6];

  // output probabilities
  float proba[TINY_K];

  preprocess_window_offset_and_standardize(win, win_proc);

  if (TINY_C == 10) {
    static float x_tc10[WIN_SAMPLES * 10];
    build_features_mag_jerk(win_proc, x_tc10);
    tinycnn_predict(x_tc10, proba);
  } else if (TINY_C == 6) {
    static float x_tc6[WIN_SAMPLES * 6];
    build_features_base6(win_proc, x_tc6);
    tinycnn_predict(x_tc6, proba);
  } else {
    // unexpected C -> output uniform
    for (int c = 0; c < TINY_K; c++) proba[c] = 1.0f / (float)TINY_K;
  }

  // Prob smoothing
  for (int c = 0; c < TINY_K; c++) {
    g_proba_ema[c] = PROBA_EMA_A * proba[c] + (1.0f - PROBA_EMA_A) * g_proba_ema[c];
  }

  // argmax
  int bestc = 0;
  float bestp = g_proba_ema[0];
  for (int c = 1; c < TINY_K; c++) {
    if (g_proba_ema[c] > bestp) { bestp = g_proba_ema[c]; bestc = c; }
  }

  // Stable decision: hysteresis + streak + hold
  uint32_t tnow = millis();
  float p_stable = g_proba_ema[g_stable_cls];
  bool in_hold = (tnow - g_last_switch_ms) < HOLD_MS;

  if (!in_hold) {
    if (bestc != g_stable_cls) {
      bool strong_enough = (bestp >= MIN_CONF_TO_SWITCH);
      bool beats_current = (bestp >= (p_stable + HYST_MARGIN));

      if (strong_enough && beats_current) {
        if (g_cand_cls == bestc) g_cand_cnt++;
        else { g_cand_cls = bestc; g_cand_cnt = 1; }

        if (g_cand_cnt >= STREAK_N) {
          g_stable_cls = bestc;
          g_last_switch_ms = tnow;
          g_cand_cnt = 0;
          g_cand_cls = -1;
        }
      } else {
        g_cand_cnt = 0;
        g_cand_cls = -1;
      }
    } else {
      g_cand_cnt = 0;
      g_cand_cls = -1;
    }
  }

  g_last_cls = g_stable_cls;
  g_last_conf = g_proba_ema[g_last_cls];
  g_last_pred_ms = millis();

  show_result(g_last_cls, g_last_conf, g_proba_ema);

  if (PRINT_SERIAL) {
    Serial.printf("Stable=%s conf=%.3f (p0=%.2f p1=%.2f p2=%.2f)\n",
      ROAD_CLASS_DE[g_last_cls], g_last_conf,
      g_proba_ema[0], g_proba_ema[1], g_proba_ema[2]
    );
  }
}
